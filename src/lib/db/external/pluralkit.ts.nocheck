/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-explicit-any */

import { CustomField, CustomFieldDatum, FrontingEntry, Member, MemberTag, System, Tag } from "../entities";
import { getTables } from "../tables";
import { fetch } from "@tauri-apps/plugin-http";
import { nilUid } from "../../util/consts";
import { appConfig, securityConfig } from "../../config";

function pkCustomField(): CustomField {
	return {
		id: window.crypto.randomUUID(),
		name: "PluralKit ID",
		priority: 1,
		default: false
	};
}

// eslint-disable-next-line @typescript-eslint/require-await
async function system(pkExport: any){
	const systemInfo: System = {
		name: pkExport.name,
		description: pkExport.description,
		id: window.crypto.randomUUID()
	};
	if (pkExport.avatar_url && securityConfig.allowRemoteContent) {
		try {
			// TODO: SQLFile
			//const request = await fetch(pkExport.avatar_url);
			//systemInfo.image = new File([await request.blob()], (pkExport.avatar_url as string).split("/").pop()!);
		} catch (_e) {
			// whatever
		}
	}

	return systemInfo;
}

function tag(pkExport: any){
	const tagMapping = new Map<string, Tag>();
	const tags: Tag[] = [];

	for (const pkGroup of pkExport.groups) {
		const tag: Tag = {
			name: pkGroup.display_name || pkGroup.name,
			description: pkGroup.description || undefined,
			color: pkGroup.color ? `#${pkGroup.color}` : undefined,
			type: 0,
			viewInLists: false,
			id: window.crypto.randomUUID()
		};
		tags.push(tag);
		tagMapping.set(pkGroup.id, tag);
	}

	return {
		tags,
		tagMapping
	};
}

// eslint-disable-next-line @typescript-eslint/require-await
async function member(pkExport: any, tagMapping: Map<string, Tag>, systemInfo: System, pkField: CustomField) {
	const memberMapping = new Map<string, Member>();
	const members: Member[] = [];
	const memberTags: MemberTag[] = [];
	const memberCustomFields: CustomFieldDatum[] = [];

	for (const pkMember of pkExport.members) {
		const member: Member = {
			name: pkMember.display_name || pkMember.name,
			system: systemInfo,
			description: pkMember.description || undefined,
			pronouns: pkMember.pronouns || undefined,
			color: pkMember.color ? `#${pkMember.color}` : undefined,
			isArchived: false,
			isPinned: false,
			isCustomFront: false,
			dateCreated: new Date(pkMember.created),
			id: window.crypto.randomUUID()
		};
		if (pkMember.avatar_url && securityConfig.allowRemoteContent) {
			try {
				// TODO: SQLFile
				//const request = await fetch(pkMember.avatar_url);
				//member.image = new File([await request.blob()], pkMember.avatar_url.split("/").pop());
			} catch (_e) {
				// whatever, again
			}
		}
		if (pkMember.banner && securityConfig.allowRemoteContent) {
			try {
				// TODO: SQLFile
				//const request = await fetch(pkMember.banner);
				//member.cover = new File([await request.blob()], pkMember.banner.split("/").pop());
			} catch (_e) {
				// whatever, again
			}
		}

		for(const tag of pkExport.groups.filter(x => (x.members as string[]).includes(pkMember.id)).map(x => tagMapping.get(x.id))){
			memberTags.push({
				id: window.crypto.randomUUID(),
				member,
				tag
			});
		}

		members.push(member);
		memberCustomFields.push({
			id: window.crypto.randomUUID(),
			member,
			field: pkField,
			value: pkMember.id
		});
		memberMapping.set(pkMember.id, member);
	}

	return {
		members,
		memberTags,
		memberCustomFields,
		memberMapping
	};
}

function frontingEntry(pkExport: any, memberMapping: Map<string, Member>){
	const trackedFronting = new Map<string, FrontingEntry>();
	const frontingEntries: FrontingEntry[] = [];

	for (const pkSwitch of pkExport.switches.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())) {
		const date = new Date(pkSwitch.timestamp);

		// check who left
		for (const id of trackedFronting.keys()) {
			if (!pkSwitch.members.includes(id)) {
				const frontingEntry = trackedFronting.get(id)!;
				frontingEntry.endTime = date;
				frontingEntries.push(frontingEntry);
				trackedFronting.delete(id);
			}
		}

		// check who's new
		for (const id of pkSwitch.members) {
			if (!trackedFronting.has(id)) {
				const frontingEntry: FrontingEntry = {
					member: memberMapping.get(id) || defaultMember(),
					startTime: date,
					isMainFronter: false,
					isLocked: false,
					id: window.crypto.randomUUID()
				};
				trackedFronting.set(id, frontingEntry);
			}
		}
	}

	// push whatever is still in the tracking map
	for (const frontingEntry of trackedFronting.values())
		frontingEntries.push(frontingEntry);

	return frontingEntries;
}

export async function importPluralKit(pkExport: any){
	const field = pkCustomField();
	const systemInfo = await system(pkExport);
	const { tags, tagMapping } = tag(pkExport);
	const { members, memberTags, memberCustomFields, memberMapping } = await member(pkExport, tagMapping, systemInfo, field);
	const frontingEntries = frontingEntry(pkExport, memberMapping);

	try {
		// WIPE AMPERSAND
		await Promise.all(Object.values(getTables()).map(x => x.clear()));

		// ADD TO DATABASE
		const tables = getTables();
		await tables.customFields.bulkAdd([field]);
		await tables.systems.bulkAdd([systemInfo]);
		appConfig.defaultSystem = systemInfo.uuid;
		await tables.tags.bulkAdd(tags);
		await tables.members.bulkAdd(members);
		await tables.memberTags.bulkAdd(memberTags);
		await tables.customFieldData.bulkAdd(memberCustomFields);
		await tables.frontingEntries.bulkAdd(frontingEntries);
	} catch (e) {
		console.error(e);
		return false;
	}

	return true;
}
